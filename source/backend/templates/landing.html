<!DOCTYPE html>

{% load static %}


<head>


  <title>{{title}}</title>
  <link rel="stylesheet" href="{% static 'styles.css' %}">
  <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/examples/js/controls/OrbitControls.min.js"></script>

</head>

<html>
<body>

<div id="page-wrapper">

<h1>Landing page</h1>


<div id="main-content">

  <p>
  <form method="post">
    {% csrf_token %}
    
    <button onclick=showLoading() value="Request results" type="submit">Submit</button>
  </form>
  </p>

  <div id="results-container">
    {% if results %}
    <div class="graph-container" id="graph_3d_traj"></div>
    {% endif %}
    <div style="display: none;" id="fetching">running simulation...</div>
  </div>

</div>

</div>
<script>

// Prevent resubmission on refresh - a bit hacky
if ( window.history.replaceState ) {
  window.history.replaceState( null, null, window.location.href );
}

const res = "{{results|safe}}";

const fetchDiv = document.getElementById("fetching")

//console.log("RESULTS BELOW")
//console.log(res)

function showLoading(){
  fetchDiv.style.display="block"
}


// Example of how to plot using a library like Chart.js or D3.js

const container = document.getElementById("graph_3d_traj")
console.log(container)
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();

const group = new THREE.Group();
scene.add(group);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; 
controls.dampingFactor = 0.05;
controls.rotateSpeed = 0.5;

renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

renderer.setClearColor(0xffffff, 1); // Set background color to white

const corners = [
  new THREE.Vector3(1, 0, -1/Math.sqrt(2)),
  new THREE.Vector3(-1, 0, -1/Math.sqrt(2)),
  new THREE.Vector3(0, 1, 1/Math.sqrt(2)),
  new THREE.Vector3(0, -1, 1/Math.sqrt(2)),
];

corners.forEach((start, i) => {
for (let j = i + 1; j < corners.length; j++) {
  const geometry = new THREE.BufferGeometry().setFromPoints([start, corners[j]]);
  const material = new THREE.LineBasicMaterial({ color: 0x000000 });
  const line = new THREE.Line(geometry, material);
  scene.add(line);
  group.add(line);
}
});

function barycentricToCartesian(a, b, c, d) {
  const v = new THREE.Vector3().addScaledVector(corners[0], a)
    .addScaledVector(corners[1], b)
    .addScaledVector(corners[2], c)
    .addScaledVector(corners[3], d);
  return v;
}



const points = JSON.parse(res);

const geometry = new THREE.SphereGeometry(0.02, 6, 6);
const color = new THREE.Color().setHSL(0.1, 1.0, 0.5);
const material = new THREE.MeshBasicMaterial({ color });
const mesh = new THREE.InstancedMesh(geometry, material, points[0][0].length);
scene.add(mesh);

const dummy = new THREE.Object3D();

group.add(mesh);

for (let i = 0; i < points[0][0].length; i++) {
  const pos = barycentricToCartesian(points[0][0][i], points[0][1][i], points[0][2][i], points[0][3][i]);
  dummy.position.copy(pos);
  dummy.updateMatrix();
  mesh.setMatrixAt(i, dummy.matrix);

}
camera.position.z = 3;

group.rotation.x = -Math.PI / 2;

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

</script>


</body>
</html>


